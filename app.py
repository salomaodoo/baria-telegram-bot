import telebot
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton
import os
import logging
import time
from flask import Flask, request
import threading
import re
import requests
import json

# Configura√ß√£o de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Configura√ß√£o do bot
BOT_TOKEN = os.getenv('BOT_TOKEN')
GROQ_API_KEY = os.getenv('GROQ_API_KEY')  # Corrigido: GROQ n√£o GROK
WEBHOOK_URL = os.getenv('WEBHOOK_URL')  # https://seu-app.railway.app/webhook
ENVIRONMENT = os.getenv('ENVIRONMENT', 'development')  # production or development

if not BOT_TOKEN:
    raise ValueError("BOT_TOKEN n√£o encontrado nas vari√°veis de ambiente")

bot = telebot.TeleBot(BOT_TOKEN, parse_mode='HTML')
app = Flask(__name__)

# Estados do usu√°rio
class UserState:
    INITIAL = "initial"
    WAITING_CONSENT = "waiting_consent"
    WAITING_NAME = "waiting_name"
    WAITING_PATIENT_CONFIRMATION = "waiting_patient_confirmation"
    WAITING_RELATIONSHIP = "waiting_relationship"
    WAITING_AGE = "waiting_age"
    WAITING_GENDER = "waiting_gender"
    WAITING_HEIGHT = "waiting_height"
    WAITING_WEIGHT = "waiting_weight"
    COMPLETED = "completed"
    HELPER_COMPLETED = "helper_completed"
    GENERAL_CHAT = "general_chat"
    QUICK_IMC_HEIGHT = "quick_imc_height"
    QUICK_IMC_WEIGHT = "quick_imc_weight"

# Armazenamento de dados do usu√°rio
user_sessions = {}

class UserData:
    def __init__(self):
        self.state = UserState.INITIAL
        self.name = ""
        self.age = ""
        self.gender = ""
        self.height = ""
        self.weight = ""
        self.is_patient = None
        self.relationship = ""
        self.last_activity = time.time()
        self.conversation_history = []

def get_user_data(user_id):
    if user_id not in user_sessions:
        user_sessions[user_id] = UserData()
    else:
        user_sessions[user_id].last_activity = time.time()
    return user_sessions[user_id]

def set_user_state(user_id, state):
    user_data = get_user_data(user_id)
    user_data.state = state
    logger.info(f"User {user_id} moved to state: {state}")

def cleanup_old_sessions():
    """Remove sess√µes antigas (mais de 1 hora)"""
    current_time = time.time()
    expired_users = []
    for user_id, user_data in user_sessions.items():
        if current_time - user_data.last_activity > 3600:  # 1 hora
            expired_users.append(user_id)
    
    for user_id in expired_users:
        del user_sessions[user_id]
        logger.info(f"Cleaned up session for user {user_id}")

def create_gender_keyboard():
    """Cria teclado inline para sele√ß√£o de g√™nero"""
    markup = InlineKeyboardMarkup()
    markup.row(
        InlineKeyboardButton("üë® Masculino", callback_data="gender_masculino"),
        InlineKeyboardButton("üë© Feminino", callback_data="gender_feminino")
    )
    markup.row(InlineKeyboardButton("‚öß Outro", callback_data="gender_outro"))
    return markup

def create_main_menu():
    """Cria menu principal de op√ß√µes"""
    markup = InlineKeyboardMarkup()
    markup.row(
        InlineKeyboardButton("üìã Crit√©rios ANS", callback_data="criterios"),
        InlineKeyboardButton("üìÑ Documentos", callback_data="documentos")
    )
    markup.row(
        InlineKeyboardButton("üè• Caminhos", callback_data="caminhos"),
        InlineKeyboardButton("üßÆ Calcular IMC", callback_data="calc_imc")
    )
    markup.row(
        InlineKeyboardButton("üí¨ Fazer pergunta", callback_data="pergunta")
    )
    return markup

def ask_grok(question, user_data=None):
    """Integra√ß√£o com Groq Cloud AI"""
    if not GROQ_API_KEY:
        return "Desculpe, a IA n√£o est√° dispon√≠vel no momento. Posso ajudar com informa√ß√µes b√°sicas sobre cirurgia bari√°trica!"
    
    try:
        # Contexto personalizado para cirurgia bari√°trica
        context = """Voc√™ √© BarIA, uma assistente virtual especializada em cirurgia bari√°trica no Brasil. 
        Voc√™ deve ser amig√°vel, emp√°tica e dar informa√ß√µes gerais sobre o processo.
        
        IMPORTANTE: 
        - N√£o forne√ßa valores/pre√ßos espec√≠ficos
        - N√£o d√™ tempos exatos de cirurgia
        - N√£o detalhe procedimentos cir√∫rgicos espec√≠ficos
        - Sempre recomende consultar profissionais habilitados para detalhes t√©cnicos
        - Seja calorosa e humana nas respostas
        - Use linguagem simples e acess√≠vel
        
        Informa√ß√µes do usu√°rio:"""
        
        if user_data and user_data.name:
            context += f"\n- Nome: {user_data.name}"
        if user_data and user_data.age:
            context += f"\n- Idade: {user_data.age} anos"
        if user_data and user_data.is_patient is not None:
            context += f"\n- √â paciente: {'Sim' if user_data.is_patient else 'N√£o'}"
        
        # Preparar hist√≥rico de conversa
        messages = [
            {"role": "system", "content": context},
        ]
        
        # Adicionar hist√≥rico recente (√∫ltimas 5 mensagens)
        if user_data and user_data.conversation_history:
            for msg in user_data.conversation_history[-5:]:
                messages.append(msg)
        
        messages.append({"role": "user", "content": question})
        
        # Fazer chamada para Groq Cloud
        headers = {
            "Authorization": f"Bearer {GROQ_API_KEY}",
            "Content-Type": "application/json"
        }
        
        data = {
            "model": "llama-3.3-70b-versatile",
            "messages": messages,
            "max_tokens": 500,
            "temperature": 0.7
        }
        
        response = requests.post(
            "https://api.groq.com/openai/v1/chat/completions",
            headers=headers,
            json=data,
            timeout=30
        )
        
        if response.status_code == 200:
            result = response.json()
            ai_response = result['choices'][0]['message']['content']
            
            # Atualizar hist√≥rico
            if user_data:
                user_data.conversation_history.append({"role": "user", "content": question})
                user_data.conversation_history.append({"role": "assistant", "content": ai_response})
                # Manter apenas √∫ltimas 10 mensagens
                if len(user_data.conversation_history) > 10:
                    user_data.conversation_history = user_data.conversation_history[-10:]
            
            return ai_response
        else:
            logger.error(f"Groq API error: {response.status_code} - {response.text}")
            return "Desculpe, tive um probleminha t√©cnico. Pode tentar novamente?"
    
    except Exception as e:
        logger.error(f"Error calling Groq API: {e}")
        return "Ops! Algo deu errado. Posso tentar responder de outra forma ou voc√™ pode perguntar novamente!"

def calculate_imc(weight, height):
    """Calcula o IMC com valida√ß√£o"""
    try:
        weight_kg = float(weight)
        height_m = float(height) / 100
        
        if weight_kg <= 0 or height_m <= 0:
            return None
            
        imc = weight_kg / (height_m ** 2)
        return round(imc, 2)
    except (ValueError, ZeroDivisionError):
        return None

def get_imc_classification(imc):
    """Classifica o IMC"""
    if imc < 18.5:
        return "Baixo peso", "‚ö†Ô∏è"
    elif imc < 25:
        return "Peso normal", "‚úÖ"
    elif imc < 30:
        return "Sobrepeso", "‚ö†Ô∏è"
    elif imc < 35:
        return "Obesidade grau I", "üî∂"
    elif imc < 40:
        return "Obesidade grau II", "üî∏"
    else:
        return "Obesidade grau III", "üî¥"

def get_pathways_message():
    """Retorna informa√ß√µes sobre caminhos"""
    return """üè• <b>Caminhos para cirurgia bari√°trica:</b>

üîπ <b>Particular:</b>
‚Ä¢ Consulte diretamente com cirurgi√µes especializados
‚Ä¢ Para informa√ß√µes sobre custos, consulte profissionais habilitados

üîπ <b>Plano de Sa√∫de:</b>
‚Ä¢ Cobertura obrigat√≥ria pela ANS
‚Ä¢ Per√≠odo de car√™ncia: 24 meses
‚Ä¢ Consulte seu plano para prazos espec√≠ficos

üîπ <b>SUS:</b>
‚Ä¢ Totalmente gratuito
‚Ä¢ Consulte unidades de sa√∫de para informa√ß√µes sobre fila de espera

üìã <b>Documentos necess√°rios:</b>
‚Ä¢ RG, CPF, comprovante de resid√™ncia
‚Ä¢ Cart√£o do SUS ou plano de sa√∫de
‚Ä¢ Hist√≥rico m√©dico"""

def is_restricted_question(text):
    """Verifica se a pergunta cont√©m temas restritos"""
    restricted_keywords = [
        # Valores e custos
        'valor', 'pre√ßo', 'custo', 'quanto custa', 'pre√ßo da cirurgia',
        'quanto paga', 'valor da opera√ß√£o', 'pre√ßo do procedimento',
        
        # Tempos espec√≠ficos de cirurgia
        'tempo de cirurgia', 'dura√ß√£o da cirurgia', 'quantas horas',
        'tempo de opera√ß√£o', 'dura√ß√£o do procedimento',
        
        # M√©todos cir√∫rgicos espec√≠ficos
        'laparoscopia', 'laparosc√≥pica', 'm√©todo cir√∫rgico',
        'como √© feita', 'como fazem', 'procedimento cir√∫rgico',
        't√©cnica cir√∫rgica', 'como operam', 'cortes', 'incis√µes'
    ]
    
    text_lower = text.lower()
    return any(keyword in text_lower for keyword in restricted_keywords)

def get_restriction_message():
    """Retorna mensagem padr√£o para temas restritos"""
    return """‚ö†Ô∏è <b>Informa√ß√£o restrita</b>

Para informa√ß√µes sobre valores, tempos de cirurgia e m√©todos cir√∫rgicos espec√≠ficos, voc√™ deve consultar diretamente com:

‚Ä¢ Cirurgi√µes especializados
‚Ä¢ Hospitais credenciados
‚Ä¢ Seu plano de sa√∫de
‚Ä¢ Unidades do SUS

Posso ajudar com outras d√∫vidas sobre crit√©rios da ANS e documenta√ß√£o necess√°ria! üíô"""

def get_gendered_message(name, gender):
    """Retorna mensagem com g√™nero apropriado"""
    if gender == "outro":
        return f"Obrigada, {name}! üòä"
    elif gender == "feminino":
        return f"Obrigada, {name}! üòä"
    else:  # masculino
        return f"Obrigado, {name}! üòä"

# Configura√ß√£o Flask
@app.route('/')
def home():
    return {
        "status": "BarIA Bot est√° rodando!",
        "bot_info": "Assistente virtual para cirurgia bari√°trica",
        "version": "3.0",
        "environment": ENVIRONMENT
    }

@app.route('/webhook', methods=['POST'])
def webhook():
    try:
        json_str = request.get_data(as_text=True)
        update = telebot.types.Update.de_json(json_str)
        bot.process_new_updates([update])
        return "OK", 200
    except Exception as e:
        logger.error(f"Webhook error: {e}")
        return "ERROR", 500

@app.route('/health')
def health():
    return {"status": "healthy", "timestamp": time.time()}

# Handlers
@bot.message_handler(commands=['start'])
def handle_start(message):
    user_id = message.from_user.id
    user_data = get_user_data(user_id)
    user_data.state = UserState.INITIAL
    
    cleanup_old_sessions()
    
    response = """Ol√°! üëã Eu sou a BarIA, sua assistente virtual focada em cirurgia bari√°trica no Brasil. 

Posso te fazer algumas perguntinhas para entender melhor sua situa√ß√£o e te ajudar nessa jornada? Ou se preferir, pode me fazer qualquer pergunta sobre o assunto!"""
    
    set_user_state(user_id, UserState.WAITING_CONSENT)
    bot.send_message(message.chat.id, response)

@bot.message_handler(commands=['criterios', 'documentos', 'caminhos', 'orientacoes'])
def handle_custom_commands(message):
    command = message.text.lower().strip()
    user_id = message.from_user.id
    user_data = get_user_data(user_id)
    
    if command == '/criterios':
        response = """üìã <b>Crit√©rios da ANS para cirurgia bari√°trica:</b>

‚úÖ <b>Crit√©rios obrigat√≥rios:</b>
‚Ä¢ IMC ‚â• 40 kg/m¬≤ OU
‚Ä¢ IMC ‚â• 35 kg/m¬≤ + comorbidades (diabetes, hipertens√£o, apneia do sono, etc.)
‚Ä¢ Idade entre 16 e 65 anos
‚Ä¢ Tentativas de tratamento cl√≠nico sem sucesso por pelo menos 2 anos

‚ö†Ô∏è <b>Observa√ß√µes importantes:</b>
‚Ä¢ Avalia√ß√£o m√©dica multidisciplinar obrigat√≥ria
‚Ä¢ Acompanhamento psicol√≥gico necess√°rio
‚Ä¢ Car√™ncia de 24 meses no plano de sa√∫de

Para avalia√ß√£o individual, consulte um cirurgi√£o especialista! üíô"""
    
    elif command == '/documentos':
        response = """üìÑ <b>Documentos necess√°rios:</b>

üîπ <b>Documentos pessoais:</b>
‚Ä¢ RG e CPF
‚Ä¢ Comprovante de resid√™ncia atualizado
‚Ä¢ Cart√£o do SUS ou carteira do plano de sa√∫de

üîπ <b>Documentos m√©dicos:</b>
‚Ä¢ Hist√≥rico m√©dico completo
‚Ä¢ Exames anteriores (se houver)
‚Ä¢ Relat√≥rios de tentativas de tratamento cl√≠nico
‚Ä¢ Comprova√ß√£o de comorbidades (se aplic√°vel)

üîπ <b>Para planos de sa√∫de:</b>
‚Ä¢ Declara√ß√£o de car√™ncia cumprida
‚Ä¢ Guia de solicita√ß√£o de procedimento

Consulte sempre com o local onde far√° o procedimento para lista completa! üíô"""
    
    elif command == '/caminhos':
        response = get_pathways_message()
    
    elif command == '/orientacoes':
        response = """üí° <b>Orienta√ß√µes gerais:</b>

üîπ <b>Antes da cirurgia:</b>
‚Ä¢ Consulte cirurgi√£o especialista
‚Ä¢ Fa√ßa avalia√ß√£o multidisciplinar
‚Ä¢ Prepare-se psicologicamente
‚Ä¢ Organize documenta√ß√£o

üîπ <b>P√≥s-operat√≥rio:</b>
‚Ä¢ Siga rigorosamente as orienta√ß√µes m√©dicas
‚Ä¢ Mantenha acompanhamento nutricional
‚Ä¢ Realize atividade f√≠sica conforme orienta√ß√£o
‚Ä¢ Participe de grupos de apoio

üîπ <b>Dicas importantes:</b>
‚Ä¢ N√£o tome decis√µes por impulso
‚Ä¢ Busque informa√ß√µes em fontes confi√°veis
‚Ä¢ Conte com apoio familiar
‚Ä¢ Tenha paci√™ncia com o processo

Outras d√∫vidas espec√≠ficas? üíô"""
    
    markup = create_main_menu()
    bot.send_message(message.chat.id, response, reply_markup=markup)

@bot.message_handler(commands=['reset'])
def handle_reset(message):
    user_id = message.from_user.id
    if user_id in user_sessions:
        del user_sessions[user_id]
    bot.send_message(message.chat.id, "‚úÖ Dados resetados! Digite /start para come√ßar novamente.")

# Handler de callback queries
@bot.callback_query_handler(func=lambda call: True)
def handle_callback(call):
    try:
        user_id = call.from_user.id
        user_data = get_user_data(user_id)
        
        # Callbacks de g√™nero
        if call.data.startswith("gender_"):
            gender = call.data.split("_")[1]
            if gender == "masculino":
                user_data.gender = "masculino"
                response_msg = f"Obrigado, {user_data.name}! üòä"
            elif gender == "feminino":
                user_data.gender = "feminino"
                response_msg = f"Obrigada, {user_data.name}! üòä"
            else:  # outro
                user_data.gender = "outro"
                response_msg = f"Obrigada, {user_data.name}! üòä"
            
            set_user_state(user_id, UserState.WAITING_HEIGHT)
            bot.edit_message_text(
                f"{response_msg}\n\n5Ô∏è‚É£ Qual √© a sua altura? (exemplo: 170 cm)",
                call.message.chat.id,
                call.message.message_id
            )
        
        # Callbacks do menu principal
        elif call.data == "criterios":
            response = """üìã <b>Crit√©rios da ANS para cirurgia bari√°trica:</b>

‚úÖ <b>Crit√©rios obrigat√≥rios:</b>
‚Ä¢ IMC ‚â• 40 kg/m¬≤ OU
‚Ä¢ IMC ‚â• 35 kg/m¬≤ + comorbidades
‚Ä¢ Idade entre 16 e 65 anos
‚Ä¢ Tentativas de tratamento cl√≠nico por 2+ anos

Para avalia√ß√£o individual, consulte um especialista! üíô"""
            
        elif call.data == "documentos":
            response = """üìÑ <b>Documentos necess√°rios:</b>

üîπ <b>Pessoais:</b> RG, CPF, comprovante resid√™ncia
üîπ <b>M√©dicos:</b> Hist√≥rico m√©dico, exames
üîπ <b>Plano:</b> Carteira, guia de solicita√ß√£o

Consulte sempre o local do procedimento! üíô"""
            
        elif call.data == "caminhos":
            response = get_pathways_message()
            
        elif call.data == "calc_imc":
            set_user_state(user_id, UserState.QUICK_IMC_HEIGHT)
            response = "üßÆ <b>Calculadora de IMC</b>\n\n1Ô∏è‚É£ Digite sua altura em cent√≠metros (exemplo: 170):"
            
        elif call.data == "pergunta":
            set_user_state(user_id, UserState.GENERAL_CHAT)
            response = "üí¨ <b>Perguntas e Respostas</b>\n\nFa√ßa sua pergunta sobre cirurgia bari√°trica e eu te ajudo! üòä"
        
        else:
            response = "Op√ß√£o n√£o reconhecida."
        
        # Responder callback
        bot.answer_callback_query(call.id)
        
        # Enviar resposta se n√£o for callback de g√™nero
        if not call.data.startswith("gender_"):
            markup = create_main_menu() if call.data != "pergunta" else None
            bot.send_message(call.message.chat.id, response, reply_markup=markup)
            
    except Exception as e:
        logger.error(f"Error handling callback: {e}")
        bot.answer_callback_query(call.id, "Erro interno. Tente novamente.")

# Handler principal de mensagens
@bot.message_handler(func=lambda message: True)
def handle_text_message(message):
    try:
        user_id = message.from_user.id
        user_data = get_user_data(user_id)
        text = message.text.strip()
        
        logger.info(f"User {user_id} ({user_data.state}): {text}")
        
        # Verificar se √© uma pergunta restrita em qualquer estado
        if is_restricted_question(text):
            markup = create_main_menu()
            bot.reply_to(message, get_restriction_message(), reply_markup=markup)
            return
        
        # Sauda√ß√µes iniciais
        if text.lower() in ['ol√°', 'oi', 'hello', 'hey', 'bom dia', 'boa tarde', 'boa noite']:
            if user_data.state == UserState.INITIAL:
                handle_start(message)
                return
        
        # Roteamento por estado
        if user_data.state == UserState.WAITING_CONSENT:
            handle_consent(message, user_data)
        elif user_data.state == UserState.WAITING_NAME:
            handle_name_input(message, user_data)
        elif user_data.state == UserState.WAITING_PATIENT_CONFIRMATION:
            handle_patient_confirmation(message, user_data)
        elif user_data.state == UserState.WAITING_RELATIONSHIP:
            handle_relationship_input(message, user_data)
        elif user_data.state == UserState.WAITING_AGE:
            handle_age_input(message, user_data)
        elif user_data.state == UserState.WAITING_GENDER:
            handle_gender_input_text(message, user_data)
        elif user_data.state == UserState.WAITING_HEIGHT:
            handle_height_input(message, user_data)
        elif user_data.state == UserState.WAITING_WEIGHT:
            handle_weight_input(message, user_data)
        elif user_data.state == UserState.QUICK_IMC_HEIGHT:
            handle_quick_imc_height(message, user_data)
        elif user_data.state == UserState.QUICK_IMC_WEIGHT:
            handle_quick_imc_weight(message, user_data)
        elif user_data.state in [UserState.COMPLETED, UserState.HELPER_COMPLETED, UserState.GENERAL_CHAT]:
            handle_general_question(message, user_data)
        else:
            markup = create_main_menu()
            bot.reply_to(message, "‚ùå Algo deu errado. Escolha uma op√ß√£o:", reply_markup=markup)
    
    except Exception as e:
        logger.error(f"Error handling message: {e}")
        markup = create_main_menu()
        bot.reply_to(message, "‚ùå Ocorreu um erro. Tente novamente:", reply_markup=markup)

# Fun√ß√µes de handler individuais
def handle_consent(message, user_data):
    text = message.text.lower().strip()
    
    if any(word in text for word in ['sim', 'claro', 'ok', 'pode', 'vamos', 'aceito']):
        set_user_state(message.from_user.id, UserState.WAITING_NAME)
        bot.reply_to(message, "Que bom! Vamos come√ßar ent√£o üòä\n\n1Ô∏è‚É£ Qual √© o seu primeiro nome?")
    elif any(word in text for word in ['n√£o', 'nao', 'agora n√£o', 'depois']):
        set_user_state(message.from_user.id, UserState.GENERAL_CHAT)
        markup = create_main_menu()
        bot.reply_to(message, "Sem problemas! Fico aqui para tirar suas d√∫vidas sobre cirurgia bari√°trica. üíô", reply_markup=markup)
    else:
        ai_response = ask_grok(f"O usu√°rio disse: '{message.text}'. Ele estava sendo perguntado se queria responder algumas perguntas para receber orienta√ß√µes personalizadas. Responda de forma amig√°vel pedindo uma confirma√ß√£o mais clara.", user_data)
        bot.reply_to(message, ai_response)

def handle_name_input(message, user_data):
    name = message.text.strip()
    
    if len(name) < 2 or len(name) > 50:
        bot.reply_to(message, "Hmm, esse nome parece estar incompleto. Pode me dizer seu primeiro nome?")
        return
    
    name = re.sub(r'[^a-zA-Z√Ä-√ø\s]', '', name).title()
    user_data.name = name
    set_user_state(message.from_user.id, UserState.WAITING_PATIENT_CONFIRMATION)
    
    bot.reply_to(message, f"Prazer te conhecer, {user_data.name}! üòä\n\n2Ô∏è‚É£ Voc√™ √© a pessoa interessada na cirurgia bari√°trica?")

def handle_patient_confirmation(message, user_data):
    text = message.text.lower().strip()
    
    if any(word in text for word in ['sim', 'sou', 'eu', 'pr√≥pria', 'mesmo']):
        user_data.is_patient = True
        set_user_state(message.from_user.id, UserState.WAITING_AGE)
        bot.reply_to(message, f"Perfeito, {user_data.name}! Vou te ajudar da melhor forma poss√≠vel üíô\n\n3Ô∏è‚É£ Qual √© a sua idade?")
    
    elif any(word in text for word in ['n√£o', 'nao', 'outra', 'algu√©m']):
        user_data.is_patient = False
        set_user_state(message.from_user.id, UserState.WAITING_RELATIONSHIP)
        bot.reply_to(message, f"Entendi, {user_data.name}. Que legal voc√™ estar apoiando essa pessoa! üíô\n\n3Ô∏è‚É£ Qual √© o seu grau de parentesco com a pessoa interessada?")
    
    else:
        ai_response = ask_grok(f"O usu√°rio disse: '{message.text}'. Ele estava sendo perguntado se era a pessoa interessada na cirurgia bari√°trica. Responda de forma amig√°vel pedindo esclarecimento.", user_data)
        bot.reply_to(message, ai_response)

def handle_relationship_input(message, user_data):
    user_data.relationship = message.text.strip()
    
    response = f"""Que bom saber, {user_data.name}! 

üíô <b>Sobre o apoio familiar:</b>

O apoio da fam√≠lia √© fundamental! Algumas dicas:
‚Ä¢ As orienta√ß√µes m√©dicas devem ser direcionadas pelos profissionais
‚Ä¢ A decis√£o final √© sempre da pessoa interessada
‚Ä¢ Seu papel √© oferecer apoio emocional e pr√°tico
‚Ä¢ Acompanhe as consultas quando poss√≠vel

Estou aqui para tirar suas d√∫vidas sobre todo o processo! üíô"""
    
    set_user_state(message.from_user.id, UserState.HELPER_COMPLETED)
    markup = create_main_menu()
    bot.reply_to(message, response, reply_markup=markup)

def handle_age_input(message, user_data):
    try:
        age = int(message.text.strip())
        if age < 16:
            bot.reply_to(message, "‚ö†Ô∏è A cirurgia bari√°trica √© indicada para pessoas a partir de 16 anos. Para menores, √© necess√°rio avalia√ß√£o m√©dica especializada.")
            return
        elif age > 65:
            age_warning = f"‚ö†Ô∏è <b>Aten√ß√£o, {user_data.name}!</b>\n\nA cirurgia bari√°trica ap√≥s os 65 anos requer avalia√ß√£o m√©dica muito criteriosa. Recomendo consultar um cirurgi√£o especialista para an√°lise individual."
            bot.reply_to(message, age_warning)
        
        user_data.age = str(age)
        set_user_state(message.from_user.id, UserState.WAITING_GENDER)
        
        gender_msg = f"4Ô∏è‚É£ Qual √© o seu g√™nero, {user_data.name}?"
        markup = create_gender_keyboard()
        bot.reply_to(message, gender_msg, reply_markup=markup)
    
    except ValueError:
        bot.reply_to(message, "Por favor, digite apenas n√∫meros para a idade (exemplo: 35)")

def handle_gender_input_text(message, user_data):
    """Fallback para entrada de g√™nero por texto"""
    gender = message.text.strip().lower()
    
    if gender in ['masculino', 'homem', 'm']:
        user_data.gender = 'masculino'
        response_msg = f"Obrigado, {user_data.name}! üòä"
    elif gender in ['feminino', 'mulher', 'f']:
        user_data.gender = 'feminino'
        response_msg = f"Obrigada, {user_data.name}! üòä"
    elif gender in ['outro', 'outros', 'n√£o-bin√°rio', 'nao-binario', 'nb']:
        user_data.gender = 'outro'
        response_msg = f"Obrigada, {user_data.name}! üòä"
    else:
        markup = create_gender_keyboard()
        bot.reply_to(message, "Pode escolher uma das op√ß√µes abaixo?", reply_markup=markup)
        return
    
    set_user_state(message.from_user.id, UserState.WAITING_HEIGHT)
    bot.reply_to(message, f"{response_msg}\n\n5Ô∏è‚É£ Qual √© a sua altura? (exemplo: 170 cm)")

def handle_height_input(message, user_data):
    try:
        height_text = message.text.strip().replace(',', '.').replace('cm', '').replace('m', '')
        height = float(height_text)
        
        if height < 100 or height > 250:
            bot.reply_to(message, "‚ö†Ô∏è Altura inv√°lida. Digite a altura em cent√≠metros (exemplo: 170)")
            return
        
        user_data.height = str(int(height))
        set_user_state(message.from_user.id, UserState.WAITING_WEIGHT)
        bot.reply_to(message, f"6Ô∏è‚É£ E qual √© o seu peso atual? (exemplo: 85 kg)")
    
    except ValueError:
        bot.reply_to(message, "Por favor, digite apenas n√∫meros para a altura (exemplo: 170)")

def handle_weight_input(message, user_data):
    try:
        weight_text = message.text.strip().replace(',', '.').replace('kg', '')
        weight = float(weight_text)
        
        if weight < 30 or weight > 300:
            bot.reply_to(message, "‚ö†Ô∏è Peso inv√°lido. Digite o peso em quilogramas (exemplo: 85)")
            return
        
        user_data.weight = str(weight)
        
        # Calcular IMC e gerar resposta personalizada
        imc = calculate_imc(user_data.weight, user_data.height)
        classification, emoji = get_imc_classification(imc)
        
        response = f"""‚úÖ <b>Perfil completo, {user_data.name}!</b>

üìä <b>Seus dados:</b>
‚Ä¢ Idade: {user_data.age} anos
‚Ä¢ Altura: {user_data.height} cm
‚Ä¢ Peso: {user_data.weight} kg
‚Ä¢ IMC: {imc} kg/m¬≤ {emoji}
‚Ä¢ Classifica√ß√£o: {classification}

"""
        
        # Orienta√ß√£o baseada no IMC
        if imc >= 40:
            response += """üéØ <b>Orienta√ß√£o:</b>
Voc√™ atende ao crit√©rio de IMC ‚â• 40 kg/m¬≤ para cirurgia bari√°trica. Recomendo consultar um cirurgi√£o especialista para avalia√ß√£o completa!"""
        elif imc >= 35:
            response += """üéØ <b>Orienta√ß√£o:</b>
Voc√™ tem IMC ‚â• 35 kg/m¬≤. Para cirurgia bari√°trica, seria necess√°rio tamb√©m ter comorbidades (diabetes, hipertens√£o, apneia do sono, etc.). Consulte um m√©dico especialista!"""
        elif imc >= 30:
            response += """üéØ <b>Orienta√ß√£o:</b>
Voc√™ est√° na faixa de obesidade grau I. A cirurgia bari√°trica geralmente √© indicada para IMC ‚â• 35 kg/m¬≤ com comorbidades ou ‚â• 40 kg/m¬≤. Consulte um endocrinologista primeiro!"""
        else:
            response += """üéØ <b>Orienta√ß√£o:</b>
Seu IMC n√£o est√° na faixa para cirurgia bari√°trica (‚â• 35 kg/m¬≤ com comorbidades ou ‚â• 40 kg/m¬≤). Consulte um nutricionista ou endocrinologista para orienta√ß√£o adequada!"""
        
        set_user_state(message.from_user.id, UserState.COMPLETED)
        markup = create_main_menu()
        bot.reply_to(message, response, reply_markup=markup)
    
    except ValueError:
        bot.reply_to(message, "Por favor, digite apenas n√∫meros para o peso (exemplo: 85)")

def handle_quick_imc_height(message, user_data):
    try:
        height_text = message.text.strip().replace(',', '.').replace('cm', '').replace('m', '')
        height = float(height_text)
        
        if height < 100 or height > 250:
            bot.reply_to(message, "‚ö†Ô∏è Altura inv√°lida. Digite a altura em cent√≠metros (exemplo: 170)")
            return
        
        user_data.height = str(int(height))
        set_user_state(message.from_user.id, UserState.QUICK_IMC_WEIGHT)
        bot.reply_to(message, "2Ô∏è‚É£ Agora digite seu peso em quilogramas (exemplo: 85):")
    
    except ValueError:
        bot.reply_to(message, "Por favor, digite apenas n√∫meros para a altura (exemplo: 170)")

def handle_quick_imc_weight(message, user_data):
    try:
        weight_text = message.text.strip().replace(',', '.').replace('kg', '')
        weight = float(weight_text)
        
        if weight < 30 or weight > 300:
            bot.reply_to(message, "‚ö†Ô∏è Peso inv√°lido. Digite o peso em quilogramas (exemplo: 85)")
            return
        
        # Calcular IMC
        imc = calculate_imc(str(weight), user_data.height)
        classification, emoji = get_imc_classification(imc)
        
        response = f"""üßÆ <b>Resultado do IMC:</b>

üìä <b>Dados:</b>
‚Ä¢ Altura: {user_data.height} cm
‚Ä¢ Peso: {weight} kg
‚Ä¢ IMC: {imc} kg/m¬≤ {emoji}
‚Ä¢ Classifica√ß√£o: {classification}

"""
        
        # Orienta√ß√£o baseada no IMC
        if imc >= 40:
            response += """üéØ <b>Orienta√ß√£o:</b>
IMC ‚â• 40 kg/m¬≤ atende ao crit√©rio para cirurgia bari√°trica. Consulte um cirurgi√£o especialista!"""
        elif imc >= 35:
            response += """üéØ <b>Orienta√ß√£o:</b>
IMC ‚â• 35 kg/m¬≤. Para cirurgia bari√°trica, seria necess√°rio ter tamb√©m comorbidades. Consulte um m√©dico especialista!"""
        elif imc >= 30:
            response += """üéØ <b>Orienta√ß√£o:</b>
Obesidade grau I. Cirurgia bari√°trica geralmente indicada para IMC ‚â• 35 com comorbidades ou ‚â• 40. Consulte um endocrinologista!"""
        else:
            response += """üéØ <b>Orienta√ß√£o:</b>
IMC n√£o est√° na faixa para cirurgia bari√°trica. Consulte um nutricionista ou endocrinologista para orienta√ß√£o adequada!"""
        
        set_user_state(message.from_user.id, UserState.GENERAL_CHAT)
        markup = create_main_menu()
        bot.reply_to(message, response, reply_markup=markup)
    
    except ValueError:
        bot.reply_to(message, "Por favor, digite apenas n√∫meros para o peso (exemplo: 85)")

def handle_general_question(message, user_data):
    """Handler para perguntas gerais usando IA"""
    try:
        # Verificar novamente se √© pergunta restrita
        if is_restricted_question(message.text):
            markup = create_main_menu()
            bot.reply_to(message, get_restriction_message(), reply_markup=markup)
            return
        
        # Mostrar que est√° processando
        processing_msg = bot.reply_to(message, "ü§î Pensando...")
        
        # Obter resposta da IA
        ai_response = ask_grok(message.text, user_data)
        
        # Editar mensagem com resposta
        markup = create_main_menu()
        bot.edit_message_text(
            f"{ai_response}\n\nüíô <i>Outras d√∫vidas?</i>",
            processing_msg.chat.id,
            processing_msg.message_id,
            reply_markup=markup
        )
    
    except Exception as e:
        logger.error(f"Error in general question handler: {e}")
        markup = create_main_menu()
        bot.reply_to(message, "Ops! Tive um probleminha. Pode tentar novamente?", reply_markup=markup)

# Fun√ß√£o de limpeza peri√≥dica
def periodic_cleanup():
    """Executa limpeza peri√≥dica das sess√µes"""
    while True:
        try:
            time.sleep(3600)  # 1 hora
            cleanup_old_sessions()
            logger.info("Periodic cleanup completed")
        except Exception as e:
            logger.error(f"Error in periodic cleanup: {e}")

# Configura√ß√£o do webhook
def setup_webhook():
    try:
        if ENVIRONMENT == 'production' and WEBHOOK_URL:
            webhook_url = f"{WEBHOOK_URL}/webhook"
            bot.remove_webhook()
            time.sleep(1)
            bot.set_webhook(url=webhook_url)
            logger.info(f"Webhook configurado: {webhook_url}")
        else:
            bot.remove_webhook()
            logger.info("Webhook removido - modo desenvolvimento")
    except Exception as e:
        logger.error(f"Erro ao configurar webhook: {e}")

# Fun√ß√£o principal
def main():
    try:
        logger.info("Iniciando BarIA Bot v3.0...")
        logger.info(f"Environment: {ENVIRONMENT}")
        
        # Configurar webhook se em produ√ß√£o
        if ENVIRONMENT == 'production':
            setup_webhook()
            
            # Iniciar thread de limpeza
            cleanup_thread = threading.Thread(target=periodic_cleanup, daemon=True)
            cleanup_thread.start()
            
            # Iniciar Flask
            port = int(os.environ.get('PORT', 5000))
            app.run(host='0.0.0.0', port=port)
        else:
            # Modo desenvolvimento - polling
            logger.info("Iniciando modo polling...")
            bot.remove_webhook()
            
            # Thread de limpeza
            cleanup_thread = threading.Thread(target=periodic_cleanup, daemon=True)
            cleanup_thread.start()
            
            # Polling
            bot.infinity_polling(timeout=60, long_polling_timeout=60)
    
    except Exception as e:
        logger.error(f"Erro cr√≠tico: {e}")
        raise

if __name__ == '__main__':
    main()
