import telebot
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton
import os
import logging
import time
from flask import Flask, request
import threading
import re

# Configura√ß√£o de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Configura√ß√£o do bot
BOT_TOKEN = os.getenv('BOT_TOKEN')
WEBHOOK_URL = os.getenv('WEBHOOK_URL')  # https://seu-app.railway.app/webhook
ENVIRONMENT = os.getenv('ENVIRONMENT', 'development')  # production or development

if not BOT_TOKEN:
    raise ValueError("BOT_TOKEN n√£o encontrado nas vari√°veis de ambiente")

bot = telebot.TeleBot(BOT_TOKEN)
app = Flask(__name__)

# Estados do usu√°rio
class UserState:
    INITIAL = "initial"
    WAITING_NAME = "waiting_name"
    WAITING_AGE = "waiting_age"
    WAITING_GENDER = "waiting_gender"
    WAITING_HEIGHT = "waiting_height"
    WAITING_WEIGHT = "waiting_weight"
    WAITING_PATIENT_CONFIRMATION = "waiting_patient_confirmation"
    WAITING_RELATIONSHIP = "waiting_relationship"
    COMPLETED = "completed"
    GENERAL_CHAT = "general_chat"

# Armazenamento de dados do usu√°rio (em produ√ß√£o, use um banco de dados)
user_sessions = {}

class UserData:
    def __init__(self):
        self.state = UserState.INITIAL
        self.name = ""
        self.age = ""
        self.gender = ""
        self.height = ""
        self.weight = ""
        self.is_patient = None
        self.relationship = ""
        self.last_activity = time.time()

def get_user_data(user_id):
    if user_id not in user_sessions:
        user_sessions[user_id] = UserData()
    else:
        user_sessions[user_id].last_activity = time.time()
    return user_sessions[user_id]

def set_user_state(user_id, state):
    user_data = get_user_data(user_id)
    user_data.state = state
    logger.info(f"User {user_id} moved to state: {state}")

def cleanup_old_sessions():
    """Remove sess√µes antigas (mais de 1 hora)"""
    current_time = time.time()
    expired_users = []
    for user_id, user_data in user_sessions.items():
        if current_time - user_data.last_activity > 3600:  # 1 hora
            expired_users.append(user_id)
    
    for user_id in expired_users:
        del user_sessions[user_id]
        logger.info(f"Cleaned up session for user {user_id}")

def calculate_imc(weight, height):
    """Calcula o IMC com valida√ß√£o melhorada"""
    try:
        weight_kg = float(weight)
        height_m = float(height) / 100
        
        if weight_kg <= 0 or height_m <= 0:
            return None
            
        imc = weight_kg / (height_m ** 2)
        return round(imc, 2)
    except (ValueError, ZeroDivisionError):
        return None

def get_imc_classification(imc):
    """Classifica o IMC com mais detalhes"""
    if imc < 18.5:
        return "Baixo peso", "‚ö†Ô∏è"
    elif imc < 25:
        return "Peso normal", "‚úÖ"
    elif imc < 30:
        return "Sobrepeso", "‚ö†Ô∏è"
    elif imc < 35:
        return "Obesidade grau I", "üî∂"
    elif imc < 40:
        return "Obesidade grau II", "üî∏"
    else:
        return "Obesidade grau III (obesidade m√≥rbida)", "üî¥"

def get_ans_criteria_message(imc):
    """Retorna mensagem detalhada sobre crit√©rios da ANS"""
    if imc >= 40:
        return """‚úÖ **Voc√™ atende aos crit√©rios da ANS para cirurgia bari√°trica:**
‚Ä¢ IMC ‚â• 40 kg/m¬≤
‚Ä¢ Indica√ß√£o para cirurgia bari√°trica"""
    elif imc >= 35:
        return """‚ö†Ô∏è **Voc√™ pode atender aos crit√©rios da ANS se tiver comorbidades:**
‚Ä¢ IMC entre 35-39,9 kg/m¬≤
‚Ä¢ Necess√°rias comorbidades como: diabetes, hipertens√£o, apneia do sono, artrose, etc.
‚Ä¢ Avalia√ß√£o m√©dica necess√°ria"""
    else:
        return """‚ùå **Pelo IMC atual, voc√™ n√£o atende aos crit√©rios b√°sicos da ANS:**
‚Ä¢ IMC < 35 kg/m¬≤
‚Ä¢ Considere acompanhamento nutricional e exerc√≠cios
‚Ä¢ Reavalie em consulta m√©dica"""

def get_pathways_message():
    """Retorna informa√ß√µes detalhadas sobre caminhos"""
    return """üè• **Caminhos para cirurgia bari√°trica:**

üîπ **Particular:**
‚Ä¢ Mais r√°pido (1-3 meses)
‚Ä¢ Escolha livre do cirurgi√£o
‚Ä¢ Custo: R$ 15.000 a R$ 50.000
‚Ä¢ Sem burocracia

üîπ **Plano de Sa√∫de:**
‚Ä¢ Cobertura obrigat√≥ria pela ANS
‚Ä¢ Per√≠odo de car√™ncia: 24 meses
‚Ä¢ Avalia√ß√£o multidisciplinar obrigat√≥ria
‚Ä¢ Tempo m√©dio: 6-12 meses

üîπ **SUS:**
‚Ä¢ Totalmente gratuito
‚Ä¢ Fila de espera: 1-3 anos
‚Ä¢ Centros especializados (poucos)
‚Ä¢ Avalia√ß√£o rigorosa

üìã **Documentos necess√°rios:**
‚Ä¢ RG, CPF, comprovante de resid√™ncia
‚Ä¢ Cart√£o do SUS ou plano de sa√∫de
‚Ä¢ Hist√≥rico m√©dico de tentativas de emagrecimento"""

# Melhor sistema de respostas autom√°ticas
class ResponseEngine:
    def __init__(self):
        self.responses = {
            'dieta': {
                'keywords': ['dieta', 'alimenta√ß√£o', 'comer', 'comida', 'nutri√ß√£o', 'card√°pio', 'regime'],
                'response': """ü•ó **Sobre alimenta√ß√£o pr√© e p√≥s-cir√∫rgica:**

**Pr√©-operat√≥rio:**
‚Ä¢ Dieta l√≠quida 1-2 semanas antes
‚Ä¢ Redu√ß√£o de carboidratos
‚Ä¢ Aumento de prote√≠nas
‚Ä¢ Hidrata√ß√£o adequada

**P√≥s-operat√≥rio:**
‚Ä¢ Fase 1: L√≠quidos (1-2 semanas)
‚Ä¢ Fase 2: Pastosos (2-4 semanas)
‚Ä¢ Fase 3: S√≥lidos macios (4-8 semanas)
‚Ä¢ Fase 4: Alimenta√ß√£o normal (ap√≥s 2 meses)

‚ö†Ô∏è **Importante:** Sempre siga as orienta√ß√µes do seu nutricionista!"""
            },
            'tecnicas': {
                'keywords': ['t√©cnica', 'bypass', 'sleeve', 'banda', 'cirurgia', 'opera√ß√£o', 'procedimento'],
                'response': """üî¨ **Principais t√©cnicas cir√∫rgicas:**

**Sleeve (Manga G√°strica):**
‚Ä¢ Remove 80% do est√¥mago
‚Ä¢ Mais simples e r√°pida
‚Ä¢ Menor risco de complica√ß√µes

**Bypass G√°strico:**
‚Ä¢ Reduz est√¥mago + desvia intestino
‚Ä¢ Maior perda de peso
‚Ä¢ Mais complexa

**Banda G√°strica:**
‚Ä¢ Anel ajust√°vel no est√¥mago
‚Ä¢ Revers√≠vel
‚Ä¢ Menos eficaz a longo prazo

üë®‚Äç‚öïÔ∏è **A escolha da t√©cnica depende de:**
‚Ä¢ Seu IMC e comorbidades
‚Ä¢ Hist√≥rico m√©dico
‚Ä¢ Prefer√™ncia do cirurgi√£o
‚Ä¢ Avalia√ß√£o individual"""
            },
            'recuperacao': {
                'keywords': ['recupera√ß√£o', 'p√≥s-operat√≥rio', 'depois', 'cicatriza√ß√£o', 'volta', 'trabalho'],
                'response': """üè• **Recupera√ß√£o p√≥s-cir√∫rgica:**

**Primeiros dias:**
‚Ä¢ Interna√ß√£o: 1-3 dias
‚Ä¢ Repouso absoluto
‚Ä¢ Dieta l√≠quida
‚Ä¢ Medica√ß√£o para dor

**Primeira semana:**
‚Ä¢ Repouso relativo
‚Ä¢ Caminhadas leves
‚Ä¢ Curativos di√°rios
‚Ä¢ Acompanhamento m√©dico

**Primeiro m√™s:**
‚Ä¢ Volta gradual √†s atividades
‚Ä¢ Exerc√≠cios leves
‚Ä¢ Dieta pastosa
‚Ä¢ Consultas semanais

**Ap√≥s 2 meses:**
‚Ä¢ Volta ao trabalho (se escrit√≥rio)
‚Ä¢ Exerc√≠cios moderados
‚Ä¢ Alimenta√ß√£o normal
‚Ä¢ Acompanhamento mensal

‚ö†Ô∏è **Complica√ß√µes poss√≠veis:**
‚Ä¢ N√°useas e v√¥mitos
‚Ä¢ Dumping syndrome
‚Ä¢ Defici√™ncias nutricionais
‚Ä¢ Necessidade de suplementa√ß√£o"""
            },
            'custos': {
                'keywords': ['custo', 'pre√ßo', 'valor', 'quanto custa', 'dinheiro', 'pagar'],
                'response': """üí∞ **Custos da cirurgia bari√°trica:**

**Cirurgia Particular:**
‚Ä¢ Sleeve: R$ 15.000 - R$ 25.000
‚Ä¢ Bypass: R$ 20.000 - R$ 35.000
‚Ä¢ Banda: R$ 12.000 - R$ 20.000

**Custos adicionais:**
‚Ä¢ Exames pr√©-operat√≥rios: R$ 2.000 - R$ 5.000
‚Ä¢ Interna√ß√£o: R$ 3.000 - R$ 8.000
‚Ä¢ Acompanhamento: R$ 2.000 - R$ 5.000/ano

**Formas de pagamento:**
‚Ä¢ √Ä vista (desconto 10-20%)
‚Ä¢ Parcelado (at√© 24x)
‚Ä¢ Financiamento m√©dico
‚Ä¢ Cons√≥rcio

üí° **Dica:** Compare pre√ßos e busque refer√™ncias do cirurgi√£o!"""
            },
            'tempo': {
                'keywords': ['tempo', 'quanto demora', 'dura√ß√£o', 'prazo', 'espera'],
                'response': """‚è∞ **Tempo para cirurgia bari√°trica:**

**Particular:**
‚Ä¢ Consulta inicial ‚Üí Cirurgia: 1-3 meses
‚Ä¢ Depende dos exames e prepara√ß√£o

**Plano de Sa√∫de:**
‚Ä¢ Ap√≥s car√™ncia: 6-12 meses
‚Ä¢ Avalia√ß√£o multidisciplinar obrigat√≥ria
‚Ä¢ Pode haver recursos e negativas

**SUS:**
‚Ä¢ Fila de espera: 1-3 anos
‚Ä¢ Varia muito por regi√£o
‚Ä¢ Poucos centros especializados

**Dura√ß√£o da cirurgia:**
‚Ä¢ Sleeve: 1-2 horas
‚Ä¢ Bypass: 2-3 horas
‚Ä¢ Laparosc√≥pica (prefer√≠vel)

‚è±Ô∏è **Prepare-se:** Use o tempo de espera para mudan√ßas de h√°bitos!"""
            }
        }
    
    def get_response(self, text, user_name=""):
        text_lower = text.lower()
        
        for category, data in self.responses.items():
            if any(keyword in text_lower for keyword in data['keywords']):
                return data['response']
        
        # Resposta padr√£o mais inteligente
        return f"""üíô Oi{f', {user_name}' if user_name else ''}! 

Estou aqui para ajudar com d√∫vidas sobre cirurgia bari√°trica. Posso falar sobre:

‚Ä¢ ü•ó **Dieta** (pr√© e p√≥s-operat√≥rio)
‚Ä¢ üî¨ **T√©cnicas** cir√∫rgicas 
‚Ä¢ üè• **Recupera√ß√£o** e cuidados
‚Ä¢ üí∞ **Custos** e formas de pagamento
‚Ä¢ ‚è∞ **Tempo** de espera
‚Ä¢ üìã **Documentos** necess√°rios

Sobre o que voc√™ gostaria de saber mais?"""

response_engine = ResponseEngine()

# Configura√ß√£o Flask
@app.route('/')
def home():
    return {
        "status": "BarIA Bot est√° rodando!",
        "bot_info": "Assistente virtual para cirurgia bari√°trica",
        "version": "2.0",
        "environment": ENVIRONMENT
    }

@app.route('/webhook', methods=['POST'])
def webhook():
    try:
        json_str = request.get_data(as_text=True)
        update = telebot.types.Update.de_json(json_str)
        bot.process_new_updates([update])
        return "OK", 200
    except Exception as e:
        logger.error(f"Webhook error: {e}")
        return "ERROR", 500

@app.route('/health')
def health():
    return {"status": "healthy", "timestamp": time.time()}

# Handlers melhorados
@bot.message_handler(commands=['start'])
def handle_start(message):
    user_id = message.from_user.id
    user_data = get_user_data(user_id)
    user_data.state = UserState.INITIAL
    
    # Limpar sess√µes antigas
    cleanup_old_sessions()
    
    username = message.from_user.first_name or "amigo(a)"
    
    response = f"""Ol√°, {username}! üëã 

Eu sou a **BarIA**, sua assistente virtual especializada em cirurgia bari√°trica no Brasil.

Posso te ajudar com:
‚Ä¢ C√°lculo de IMC e an√°lise
‚Ä¢ Crit√©rios da ANS
‚Ä¢ Caminhos para cirurgia
‚Ä¢ D√∫vidas sobre procedimentos
‚Ä¢ Orienta√ß√µes gerais

Como posso te ajudar hoje?"""
    
    keyboard = InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        InlineKeyboardButton("üìä Fazer avalia√ß√£o completa", callback_data="start_questions"),
        InlineKeyboardButton("üí¨ S√≥ quero conversar", callback_data="general_chat"),
        InlineKeyboardButton("üìã Ver comandos", callback_data="help")
    )
    
    bot.send_message(message.chat.id, response, reply_markup=keyboard, parse_mode='Markdown')

@bot.message_handler(commands=['help'])
def handle_help(message):
    help_text = """ü§ñ **Comandos dispon√≠veis:**

‚Ä¢ `/start` - Iniciar conversa
‚Ä¢ `/help` - Ver esta ajuda
‚Ä¢ `/reset` - Recome√ßar avalia√ß√£o

**Posso falar sobre:**
‚Ä¢ Dieta pr√© e p√≥s-operat√≥rio
‚Ä¢ T√©cnicas cir√∫rgicas
‚Ä¢ Recupera√ß√£o e cuidados
‚Ä¢ Custos e formas de pagamento
‚Ä¢ Tempo de espera
‚Ä¢ Crit√©rios da ANS

Digite qualquer d√∫vida que eu respondo! üíô"""
    
    bot.send_message(message.chat.id, help_text, parse_mode='Markdown')

@bot.message_handler(commands=['reset'])
def handle_reset(message):
    user_id = message.from_user.id
    if user_id in user_sessions:
        del user_sessions[user_id]
    bot.send_message(message.chat.id, "‚úÖ Dados resetados! Digite /start para come√ßar novamente.")

# Callback handlers
@bot.callback_query_handler(func=lambda call: call.data == "start_questions")
def start_questions(call):
    user_id = call.from_user.id
    set_user_state(user_id, UserState.WAITING_NAME)
    
    bot.edit_message_text(
        "üìù **Vamos come√ßar sua avalia√ß√£o!**\n\n1Ô∏è‚É£ Qual √© o seu primeiro nome?",
        call.message.chat.id,
        call.message.message_id,
        parse_mode='Markdown'
    )

@bot.callback_query_handler(func=lambda call: call.data == "general_chat")
def general_chat(call):
    user_id = call.from_user.id
    set_user_state(user_id, UserState.GENERAL_CHAT)
    
    bot.edit_message_text(
        "üí¨ **Perfeito!** Estou aqui para tirar suas d√∫vidas sobre cirurgia bari√°trica.\n\nPode me perguntar qualquer coisa! üíô",
        call.message.chat.id,
        call.message.message_id,
        parse_mode='Markdown'
    )

@bot.callback_query_handler(func=lambda call: call.data == "help")
def help_callback(call):
    handle_help(call.message)

# Handler principal de mensagens
@bot.message_handler(func=lambda message: True)
def handle_text_message(message):
    try:
        user_id = message.from_user.id
        user_data = get_user_data(user_id)
        text = message.text.strip()
        
        # Log da mensagem
        logger.info(f"User {user_id} ({user_data.state}): {text}")
        
        # Sauda√ß√µes iniciais
        if text.lower() in ['ol√°', 'oi', 'hello', 'hey', 'bom dia', 'boa tarde', 'boa noite']:
            if user_data.state == UserState.INITIAL:
                handle_start(message)
                return
        
        # Fluxo de coleta de dados
        if user_data.state == UserState.WAITING_NAME:
            handle_name_input(message, user_data)
        elif user_data.state == UserState.WAITING_PATIENT_CONFIRMATION:
            handle_patient_confirmation(message, user_data)
        elif user_data.state == UserState.WAITING_RELATIONSHIP:
            handle_relationship_input(message, user_data)
        elif user_data.state == UserState.WAITING_AGE:
            handle_age_input(message, user_data)
        elif user_data.state == UserState.WAITING_GENDER:
            handle_gender_input(message, user_data)
        elif user_data.state == UserState.WAITING_HEIGHT:
            handle_height_input(message, user_data)
        elif user_data.state == UserState.WAITING_WEIGHT:
            handle_weight_input(message, user_data)
        elif user_data.state == UserState.GENERAL_CHAT or user_data.state == UserState.COMPLETED:
            handle_general_question(message, user_data)
        else:
            bot.reply_to(message, "‚ùå Algo deu errado. Digite /start para come√ßar novamente.")
    
    except Exception as e:
        logger.error(f"Error handling message: {e}")
        bot.reply_to(message, "‚ùå Ocorreu um erro. Tente novamente ou digite /start.")

def handle_name_input(message, user_data):
    name = message.text.strip()
    
    # Valida√ß√£o b√°sica do nome
    if len(name) < 2 or len(name) > 50:
        bot.reply_to(message, "‚ùå Por favor, digite um nome v√°lido (entre 2 e 50 caracteres).")
        return
    
    # Limpar caracteres especiais
    name = re.sub(r'[^a-zA-Z√Ä-√ø\s]', '', name).title()
    
    user_data.name = name
    set_user_state(message.from_user.id, UserState.WAITING_PATIENT_CONFIRMATION)
    
    bot.reply_to(message, 
        f"Obrigada, **{user_data.name}**! üòä\n\n2Ô∏è‚É£ Voc√™ √© a pessoa interessada na cirurgia bari√°trica, ou est√° buscando informa√ß√µes para auxiliar outra pessoa?",
        parse_mode='Markdown'
    )

def handle_patient_confirmation(message, user_data):
    text = message.text.lower().strip()
    
    if any(word in text for word in ['sim', 'sou', 'eu', 'pr√≥pria', 'mesmo', 'para mim', 'minha', 'meu']):
        user_data.is_patient = True
        set_user_state(message.from_user.id, UserState.WAITING_AGE)
        bot.reply_to(message, 
            f"Perfeito, **{user_data.name}**! Vamos continuar sua avalia√ß√£o.\n\n3Ô∏è‚É£ Qual √© a sua idade?",
            parse_mode='Markdown'
        )
    
    elif any(word in text for word in ['n√£o', 'nao', 'outra', 'outra pessoa', 'algu√©m', 'familiar', 'parente']):
        user_data.is_patient = False
        set_user_state(message.from_user.id, UserState.WAITING_RELATIONSHIP)
        bot.reply_to(message, 
            f"Entendi, **{user_data.name}**. √â muito importante o apoio da fam√≠lia! üë®‚Äçüë©‚Äçüëß‚Äçüë¶\n\n3Ô∏è‚É£ Qual √© o seu grau de parentesco com a pessoa interessada?",
            parse_mode='Markdown'
        )
    
    else:
        bot.reply_to(message, "‚ùì Por favor, me diga se **voc√™** √© a pessoa interessada na cirurgia ou se est√° buscando informa√ß√µes para **auxiliar outra pessoa**.")

def handle_relationship_input(message, user_data):
    user_data.relationship = message.text.strip()
    
    message_text = f"""Obrigada pela informa√ß√£o, **{user_data.name}**! 

üíô **Orienta√ß√µes importantes sobre apoio familiar:**

‚Ä¢ ‚úÖ As orienta√ß√µes m√©dicas devem sempre ser direcionadas pelos profissionais
‚Ä¢ ‚úÖ A decis√£o final √© sempre da pessoa interessada
‚Ä¢ ‚ùå N√£o force ou pressione procedimentos cir√∫rgicos
‚Ä¢ üí™ Seu papel √© oferecer apoio emocional e acompanhamento

**üìÑ Documentos que podem ser necess√°rios:**
‚Ä¢ RG e CPF
‚Ä¢ Cart√£o do SUS ou plano de sa√∫de
‚Ä¢ Comprovante de resid√™ncia
‚Ä¢ Exames m√©dicos (ser√£o solicitados pelo cirurgi√£o)

Posso continuar te ajudando com orienta√ß√µes gerais sobre o processo. √â s√≥ me perguntar! üíô"""
    
    set_user_state(message.from_user.id, UserState.COMPLETED)
    bot.reply_to(message, message_text, parse_mode='Markdown')

def handle_age_input(message, user_data):
    try:
        age = int(message.text.strip())
        if age < 16:
            bot.reply_to(message, "‚ùå A cirurgia bari√°trica √© recomendada apenas para pessoas com 16 anos ou mais.")
            return
        elif age > 100:
            bot.reply_to(message, "‚ùå Por favor, digite uma idade v√°lida.")
            return
        
        user_data.age = str(age)
        set_user_state(message.from_user.id, UserState.WAITING_GENDER)
        
        bot.reply_to(message, 
            f"Obrigada, **{user_data.name}**! üòä\n\n4Ô∏è‚É£ Qual √© o seu g√™nero?\n\n‚Ä¢ Masculino\n‚Ä¢ Feminino\n‚Ä¢ Outro",
            parse_mode='Markdown'
        )
    
    except ValueError:
        bot.reply_to(message, "‚ùå Por favor, digite apenas n√∫meros para a idade (ex: 25).")

def handle_gender_input(message, user_data):
    gender = message.text.strip().lower()
    
    if gender in ['masculino', 'homem', 'macho', 'm', 'male']:
        user_data.gender = 'masculino'
    elif gender in ['feminino', 'mulher', 'f√™mea', 'f', 'female']:
        user_data.gender = 'feminino'
    elif gender in ['outro', 'outros', 'n√£o-bin√°rio', 'nao-binario', 'nb', 'non-binary']:
        user_data.gender = 'outro'
    else:
        bot.reply_to(message, "‚ùå Por favor, escolha: **masculino**, **feminino** ou **outro**.")
        return
    
    set_user_state(message.from_user.id, UserState.WAITING_HEIGHT)
    bot.reply_to(message, 
        f"Obrigada, **{user_data.name}**! üòä\n\n5Ô∏è‚É£ Qual √© a sua altura?\n\nüìè Digite em cent√≠metros (ex: **170**)",
        parse_mode='Markdown'
    )

def handle_height_input(message, user_data):
    try:
        height_text = message.text.strip().replace(',', '.')
        height = float(height_text)
        
        if height < 100 or height > 250:
            bot.reply_to(message, "‚ùå Por favor, digite uma altura v√°lida em cent√≠metros (ex: **170**).")
            return
        
        user_data.height = str(height)
        set_user_state(message.from_user.id, UserState.WAITING_WEIGHT)
        
        bot.reply_to(message, 
            f"Obrigada, **{user_data.name}**! üòä\n\n6Ô∏è‚É£ Qual √© o seu peso atual?\n\n‚öñÔ∏è Digite em quilos (ex: **85**)",
            parse_mode='Markdown'
        )
    
    except ValueError:
        bot.reply_to(message, "‚ùå Por favor, digite apenas n√∫meros para a altura (ex: **170**).")

def handle_weight_input(message, user_data):
    try:
        weight_text = message.text.strip().replace(',', '.')
        weight = float(weight_text)
        
        if weight < 30 or weight > 300:
            bot.reply_to(message, "‚ùå Por favor, digite um peso v√°lido em quilos (ex: **85**).")
            return
        
        user_data.weight = str(weight)
        set_user_state(message.from_user.id, UserState.COMPLETED)
        
        # Calcular IMC e enviar relat√≥rio completo
        send_complete_report(message, user_data)
    
    except ValueError:
        bot.reply_to(message, "‚ùå Por favor, digite apenas n√∫meros para o peso (ex: **85**).")

def send_complete_report(message, user_data):
    imc = calculate_imc(user_data.weight, user_data.height)
    
    if imc is None:
        bot.reply_to(message, "‚ùå Erro ao calcular IMC. Verifique os dados e tente novamente.")
        return
    
    classification, icon = get_imc_classification(imc)
    ans_criteria = get_ans_criteria_message(imc)
    pathways = get_pathways_message()
    
    report = f"""‚úÖ **An√°lise completa - {user_data.name}**

üìä **Seus dados:**
‚Ä¢ **Nome:** {user_data.name}
‚Ä¢ **Idade:** {user_data.age} anos
‚Ä¢ **Altura:** {user_data.height} cm
‚Ä¢ **Peso:** {user_data.weight} kg

üî¢ **IMC:** {imc} kg/m¬≤
{icon} **Classifica√ß√£o:** {classification}

{ans_criteria}

{pathways}

üí° **Pr√≥ximos passos recomendados:**
1. ‚úÖ Consulte um cirurgi√£o bari√°trico qualificado
2. ‚úÖ Realize avalia√ß√£o multidisciplinar completa
3. ‚úÖ Fa√ßa todos os exames pr√©-operat√≥rios
4. ‚úÖ Prepare-se psicologicamente para a mudan√ßa

Posso continuar te ajudando com d√∫vidas espec√≠ficas! √â s√≥ me perguntar. üíô"""
    
    bot.reply_to(message, report, parse_mode='Markdown')

def handle_general_question(message, user_data):
    """Sistema melhorado de respostas"""
    text = message.text.strip()
    
    # Obter resposta do sistema inteligente
    response = response_engine.get_response(text, user_data.name)
    
    bot.reply_to(message, response, parse_mode='Markdown')

# Handlers de erro
@bot.message_handler(func=lambda message: True, content_types=['photo', 'video', 'document', 'audio', 'voice'])
def handle_media(message):
    bot.reply_to(message, 
        "üìé Obrigada pelo arquivo! No momento, trabalho apenas com mensagens de texto.\n\nComo posso te ajudar com suas d√∫vidas sobre cirurgia bari√°trica? üíô"
    )

def setup_webhook():
    """Configura webhook para produ√ß√£o"""
    if ENVIRONMENT == 'production' and WEBHOOK_URL:
        try:
            bot.remove_webhook()
            bot.set_webhook(url=WEBHOOK_URL)
            logger.info(f"Webhook configurado: {WEBHOOK_URL}")
        except Exception as e:
            logger.error(f"Erro ao configurar webhook: {e}")

def run_bot():
    """Executa o bot"""
    logger.info("ü§ñ BarIA iniciada! Bot rodando...")
    
    if ENVIRONMENT == 'production':
        setup_webhook()
    else:
        # Desenvolvimento - usar polling
        bot.remove_webhook()
        bot.infinity_polling()

# Inicializa√ß√£o
if __name__ == "__main__":
    port = int(os.environ.get('PORT', 5000))
    
    if ENVIRONMENT == 'production':
        # Produ√ß√£o - webhook
        setup_webhook()
        app.run(host='0.0.0.0', port=port, debug=False)
    else:
        # Desenvolvimento - polling + Flask
        bot_thread = threading.Thread(target=run_bot)
        bot_thread.daemon = True
        bot_thread.start()
        app.run(host='0.0.0.0', port=port, debug=True)
