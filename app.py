import telebot
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton
import os
import logging
import time
from flask import Flask, request
import threading
import re

# Configura√ß√£o de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Configura√ß√£o do bot
BOT_TOKEN = os.getenv('BOT_TOKEN')
WEBHOOK_URL = os.getenv('WEBHOOK_URL')  # https://seu-app.railway.app/webhook
ENVIRONMENT = os.getenv('ENVIRONMENT', 'development')  # production or development

if not BOT_TOKEN:
    raise ValueError("BOT_TOKEN n√£o encontrado nas vari√°veis de ambiente")

bot = telebot.TeleBot(BOT_TOKEN)
app = Flask(__name__)

# Estados do usu√°rio
class UserState:
    INITIAL = "initial"
    WAITING_CONSENT = "waiting_consent"
    WAITING_NAME = "waiting_name"
    WAITING_PATIENT_CONFIRMATION = "waiting_patient_confirmation"
    WAITING_RELATIONSHIP = "waiting_relationship"
    WAITING_AGE = "waiting_age"
    WAITING_GENDER = "waiting_gender"
    WAITING_HEIGHT = "waiting_height"
    WAITING_WEIGHT = "waiting_weight"
    COMPLETED = "completed"
    HELPER_COMPLETED = "helper_completed"
    GENERAL_CHAT = "general_chat"

# Armazenamento de dados do usu√°rio
user_sessions = {}

class UserData:
    def __init__(self):
        self.state = UserState.INITIAL
        self.name = ""
        self.age = ""
        self.gender = ""
        self.height = ""
        self.weight = ""
        self.is_patient = None
        self.relationship = ""
        self.last_activity = time.time()

def get_user_data(user_id):
    if user_id not in user_sessions:
        user_sessions[user_id] = UserData()
    else:
        user_sessions[user_id].last_activity = time.time()
    return user_sessions[user_id]

def set_user_state(user_id, state):
    user_data = get_user_data(user_id)
    user_data.state = state
    logger.info(f"User {user_id} moved to state: {state}")

def cleanup_old_sessions():
    """Remove sess√µes antigas (mais de 1 hora)"""
    current_time = time.time()
    expired_users = []
    for user_id, user_data in user_sessions.items():
        if current_time - user_data.last_activity > 3600:  # 1 hora
            expired_users.append(user_id)
    
    for user_id in expired_users:
        del user_sessions[user_id]
        logger.info(f"Cleaned up session for user {user_id}")

def calculate_imc(weight, height):
    """Calcula o IMC com valida√ß√£o"""
    try:
        weight_kg = float(weight)
        height_m = float(height) / 100
        
        if weight_kg <= 0 or height_m <= 0:
            return None
            
        imc = weight_kg / (height_m ** 2)
        return round(imc, 2)
    except (ValueError, ZeroDivisionError):
        return None

def get_imc_classification(imc):
    """Classifica o IMC"""
    if imc < 18.5:
        return "Baixo peso", "‚ö†Ô∏è"
    elif imc < 25:
        return "Peso normal", "‚úÖ"
    elif imc < 30:
        return "Sobrepeso", "‚ö†Ô∏è"
    elif imc < 35:
        return "Obesidade grau I", "üî∂"
    elif imc < 40:
        return "Obesidade grau II", "üî∏"
    else:
        return "Obesidade grau III", "üî¥"

def get_ans_criteria_message(imc):
    """Retorna mensagem sobre crit√©rios da ANS"""
    if imc >= 40:
        return """‚úÖ **Pelo seu IMC, voc√™ atende aos crit√©rios da ANS para cirurgia bari√°trica:**
‚Ä¢ IMC ‚â• 40 kg/m¬≤"""
    elif imc >= 35:
        return """‚ö†Ô∏è **Voc√™ pode atender aos crit√©rios da ANS se tiver comorbidades:**
‚Ä¢ IMC entre 35-39,9 kg/m¬≤
‚Ä¢ √â necess√°rio ter comorbidades como diabetes, hipertens√£o, apneia do sono, etc.
‚Ä¢ Ser√° preciso avalia√ß√£o m√©dica para confirmar"""
    else:
        return """‚ùå **Pelo IMC atual, voc√™ n√£o atende aos crit√©rios b√°sicos da ANS:**
‚Ä¢ IMC < 35 kg/m¬≤
‚Ä¢ Converse com um m√©dico sobre outras op√ß√µes"""

def get_pathways_message():
    """Retorna informa√ß√µes sobre caminhos - SEM VALORES"""
    return """üè• **Caminhos para cirurgia bari√°trica:**

üîπ **Particular:**
‚Ä¢ Consulte diretamente com cirurgi√µes especializados
‚Ä¢ Para informa√ß√µes sobre custos, consulte profissionais habilitados

üîπ **Plano de Sa√∫de:**
‚Ä¢ Cobertura obrigat√≥ria pela ANS
‚Ä¢ Per√≠odo de car√™ncia: 24 meses
‚Ä¢ Consulte seu plano para prazos espec√≠ficos

üîπ **SUS:**
‚Ä¢ Totalmente gratuito
‚Ä¢ Consulte unidades de sa√∫de para informa√ß√µes sobre fila de espera

üìã **Documentos necess√°rios:**
‚Ä¢ RG, CPF, comprovante de resid√™ncia
‚Ä¢ Cart√£o do SUS ou plano de sa√∫de
‚Ä¢ Hist√≥rico m√©dico"""

def is_restricted_question(text):
    """Verifica se a pergunta cont√©m temas restritos"""
    restricted_keywords = [
        # Valores e custos
        'valor', 'pre√ßo', 'custo', 'quanto custa', 'pre√ßo da cirurgia',
        'quanto paga', 'valor da opera√ß√£o', 'pre√ßo do procedimento',
        
        # Tempos espec√≠ficos de cirurgia
        'tempo de cirurgia', 'dura√ß√£o da cirurgia', 'quantas horas',
        'tempo de opera√ß√£o', 'dura√ß√£o do procedimento',
        
        # M√©todos cir√∫rgicos espec√≠ficos
        'laparoscopia', 'laparosc√≥pica', 'm√©todo cir√∫rgico',
        'como √© feita', 'como fazem', 'procedimento cir√∫rgico',
        't√©cnica cir√∫rgica', 'como operam', 'cortes', 'incis√µes'
    ]
    
    text_lower = text.lower()
    return any(keyword in text_lower for keyword in restricted_keywords)

def get_restriction_message():
    """Retorna mensagem padr√£o para temas restritos"""
    return """‚ö†Ô∏è **Informa√ß√£o restrita**

Para informa√ß√µes sobre valores, tempos de cirurgia e m√©todos cir√∫rgicos espec√≠ficos, voc√™ deve consultar diretamente com:

‚Ä¢ Cirurgi√µes especializados
‚Ä¢ Hospitais credenciados
‚Ä¢ Seu plano de sa√∫de
‚Ä¢ Unidades do SUS

Posso ajudar com outras d√∫vidas sobre crit√©rios da ANS e documenta√ß√£o necess√°ria! üíô"""

def get_gender_neutral_message(name):
    """Retorna mensagem sem g√™nero espec√≠fico"""
    return f"Obrigada, {name}! üòä"

def get_gendered_message(name, gender):
    """Retorna mensagem com g√™nero apropriado"""
    if gender == "outro":
        return f"Obrigada, {name}! üòä"
    elif gender == "feminino":
        return f"Obrigada, {name}! üòä"
    else:  # masculino
        return f"Obrigado, {name}! üòä"

# Configura√ß√£o Flask
@app.route('/')
def home():
    return {
        "status": "BarIA Bot est√° rodando!",
        "bot_info": "Assistente virtual para cirurgia bari√°trica",
        "version": "2.0",
        "environment": ENVIRONMENT
    }

@app.route('/webhook', methods=['POST'])
def webhook():
    try:
        json_str = request.get_data(as_text=True)
        update = telebot.types.Update.de_json(json_str)
        bot.process_new_updates([update])
        return "OK", 200
    except Exception as e:
        logger.error(f"Webhook error: {e}")
        return "ERROR", 500

@app.route('/health')
def health():
    return {"status": "healthy", "timestamp": time.time()}

# Handlers
@bot.message_handler(commands=['start'])
def handle_start(message):
    user_id = message.from_user.id
    user_data = get_user_data(user_id)
    user_data.state = UserState.INITIAL
    
    cleanup_old_sessions()
    
    response = """Ol√°! üëã Eu sou a BarIA, sua assistente virtual focada em cirurgia bari√°trica no Brasil. Posso te fazer algumas perguntinhas para entender melhor sua situa√ß√£o e te ajudar nessa jornada?"""
    
    set_user_state(user_id, UserState.WAITING_CONSENT)
    bot.send_message(message.chat.id, response)

@bot.message_handler(commands=['help'])
def handle_help(message):
    help_text = """ü§ñ **Comandos dispon√≠veis:**

‚Ä¢ `/start` - Iniciar conversa
‚Ä¢ `/help` - Ver esta ajuda
‚Ä¢ `/reset` - Recome√ßar avalia√ß√£o

Digite /start para come√ßar! üíô"""
    
    bot.send_message(message.chat.id, help_text)

@bot.message_handler(commands=['reset'])
def handle_reset(message):
    user_id = message.from_user.id
    if user_id in user_sessions:
        del user_sessions[user_id]
    bot.send_message(message.chat.id, "‚úÖ Dados resetados! Digite /start para come√ßar novamente.")

# Handler principal de mensagens
@bot.message_handler(func=lambda message: True)
def handle_text_message(message):
    try:
        user_id = message.from_user.id
        user_data = get_user_data(user_id)
        text = message.text.strip()
        
        logger.info(f"User {user_id} ({user_data.state}): {text}")
        
        # Verificar se √© uma pergunta restrita
        if is_restricted_question(text):
            bot.reply_to(message, get_restriction_message())
            return
        
        # Sauda√ß√µes iniciais
        if text.lower() in ['ol√°', 'oi', 'hello', 'hey', 'bom dia', 'boa tarde', 'boa noite']:
            if user_data.state == UserState.INITIAL:
                handle_start(message)
                return
        
        # Fluxo sequencial obrigat√≥rio
        if user_data.state == UserState.WAITING_CONSENT:
            handle_consent(message, user_data)
        elif user_data.state == UserState.WAITING_NAME:
            handle_name_input(message, user_data)
        elif user_data.state == UserState.WAITING_PATIENT_CONFIRMATION:
            handle_patient_confirmation(message, user_data)
        elif user_data.state == UserState.WAITING_RELATIONSHIP:
            handle_relationship_input(message, user_data)
        elif user_data.state == UserState.WAITING_AGE:
            handle_age_input(message, user_data)
        elif user_data.state == UserState.WAITING_GENDER:
            handle_gender_input(message, user_data)
        elif user_data.state == UserState.WAITING_HEIGHT:
            handle_height_input(message, user_data)
        elif user_data.state == UserState.WAITING_WEIGHT:
            handle_weight_input(message, user_data)
        elif user_data.state in [UserState.COMPLETED, UserState.HELPER_COMPLETED, UserState.GENERAL_CHAT]:
            handle_general_question(message, user_data)
        else:
            bot.reply_to(message, "‚ùå Algo deu errado. Digite /start para come√ßar novamente.")
    
    except Exception as e:
        logger.error(f"Error handling message: {e}")
        bot.reply_to(message, "‚ùå Ocorreu um erro. Tente novamente ou digite /start.")

def handle_consent(message, user_data):
    text = message.text.lower().strip()
    
    if any(word in text for word in ['sim', 'claro', 'ok', 'pode', 'vamos', 'aceito']):
        set_user_state(message.from_user.id, UserState.WAITING_NAME)
        bot.reply_to(message, "1Ô∏è‚É£ Qual √© o seu primeiro nome?")
    elif any(word in text for word in ['n√£o', 'nao', 'agora n√£o', 'depois']):
        set_user_state(message.from_user.id, UserState.GENERAL_CHAT)
        bot.reply_to(message, "Sem problemas! Posso te ajudar com d√∫vidas sobre cirurgia bari√°trica. √â s√≥ me perguntar! üíô")
    else:
        bot.reply_to(message, "Por favor, responda com 'sim' ou 'n√£o'. Posso te fazer algumas perguntas para te ajudar melhor?")

def handle_name_input(message, user_data):
    name = message.text.strip()
    
    if len(name) < 2 or len(name) > 50:
        bot.reply_to(message, "Por favor, digite um nome v√°lido.")
        return
    
    name = re.sub(r'[^a-zA-Z√Ä-√ø\s]', '', name).title()
    user_data.name = name
    set_user_state(message.from_user.id, UserState.WAITING_PATIENT_CONFIRMATION)
    
    bot.reply_to(message, f"Obrigada, {user_data.name}! üòä\n\n2Ô∏è‚É£ Voc√™ √© a pessoa interessada na cirurgia bari√°trica?")

def handle_patient_confirmation(message, user_data):
    text = message.text.lower().strip()
    
    if any(word in text for word in ['sim', 'sou', 'eu', 'pr√≥pria', 'mesmo']):
        user_data.is_patient = True
        set_user_state(message.from_user.id, UserState.WAITING_AGE)
        bot.reply_to(message, f"Perfeito, {user_data.name}!\n\n3Ô∏è‚É£ Qual √© a sua idade?")
    
    elif any(word in text for word in ['n√£o', 'nao', 'outra', 'algu√©m']):
        user_data.is_patient = False
        set_user_state(message.from_user.id, UserState.WAITING_RELATIONSHIP)
        bot.reply_to(message, f"Entendi, {user_data.name}. √â muito importante o apoio da fam√≠lia!\n\n3Ô∏è‚É£ Qual √© o seu grau de parentesco com a pessoa interessada?")
    
    else:
        bot.reply_to(message, "Por favor, responda 'sim' se voc√™ √© a pessoa interessada na cirurgia, ou 'n√£o' se est√° buscando informa√ß√µes para auxiliar outra pessoa.")

def handle_relationship_input(message, user_data):
    user_data.relationship = message.text.strip()
    
    message_text = f"""Obrigada, {user_data.name}!

üíô **Orienta√ß√µes sobre apoio familiar:**

‚Ä¢ As orienta√ß√µes m√©dicas devem sempre ser direcionadas pelos profissionais habilitados
‚Ä¢ A decis√£o final √© sempre da pessoa interessada
‚Ä¢ N√£o √© √©tico for√ßar ou indicar de forma incisiva procedimentos cir√∫rgicos a outra pessoa
‚Ä¢ Seu papel √© oferecer apoio emocional

**Documentos que podem ser necess√°rios:**
‚Ä¢ RG e CPF
‚Ä¢ Cart√£o do SUS ou plano de sa√∫de
‚Ä¢ Comprovante de resid√™ncia

Posso continuar te ajudando com d√∫vidas sobre o processo. √â s√≥ me perguntar! üíô"""
    
    set_user_state(message.from_user.id, UserState.HELPER_COMPLETED)
    bot.reply_to(message, message_text)

def handle_age_input(message, user_data):
    try:
        age = int(message.text.strip())
        if age < 16:
            bot.reply_to(message, "A cirurgia bari√°trica √© recomendada apenas para pessoas com 16 anos ou mais.")
            return
        elif age > 100:
            bot.reply_to(message, "Por favor, digite uma idade v√°lida.")
            return
        
        user_data.age = str(age)
        set_user_state(message.from_user.id, UserState.WAITING_GENDER)
        
        response_msg = get_gendered_message(user_data.name, user_data.gender) if user_data.gender else f"Obrigada, {user_data.name}! üòä"
        bot.reply_to(message, f"{response_msg}\n\n4Ô∏è‚É£ Qual √© o seu g√™nero?\n\n‚Ä¢ Masculino\n‚Ä¢ Feminino\n‚Ä¢ Outro")
    
    except ValueError:
        bot.reply_to(message, "Por favor, digite apenas n√∫meros para a idade.")

def handle_gender_input(message, user_data):
    gender = message.text.strip().lower()
    
    if gender in ['masculino', 'homem', 'm']:
        user_data.gender = 'masculino'
        response_msg = f"Obrigado, {user_data.name}! üòä"
    elif gender in ['feminino', 'mulher', 'f']:
        user_data.gender = 'feminino'
        response_msg = f"Obrigada, {user_data.name}! üòä"
    elif gender in ['outro', 'outros', 'n√£o-bin√°rio', 'nao-binario', 'nb']:
        user_data.gender = 'outro'
        response_msg = f"Obrigada, {user_data.name}! üòä"
    else:
        bot.reply_to(message, "Por favor, escolha: masculino, feminino ou outro.")
        return
    
    set_user_state(message.from_user.id, UserState.WAITING_HEIGHT)
    bot.reply_to(message, f"{response_msg}\n\n5Ô∏è‚É£ Qual √© a sua altura?\n\nDigite em cent√≠metros (exemplo: 170)")

def handle_height_input(message, user_data):
    try:
        height_text = message.text.strip().replace(',', '.')
        height = float(height_text)
        
        if height < 100 or height > 250:
            bot.reply_to(message, "Por favor, digite uma altura v√°lida em cent√≠metros.")
            return
        
        user_data.height = str(height)
        set_user_state(message.from_user.id, UserState.WAITING_WEIGHT)
        
        response_msg = get_gendered_message(user_data.name, user_data.gender)
        bot.reply_to(message, f"{response_msg}\n\n6Ô∏è‚É£ Qual √© o seu peso atual?\n\nDigite em quilos (exemplo: 85)")
    
    except ValueError:
        bot.reply_to(message, "Por favor, digite apenas n√∫meros para a altura.")

def handle_weight_input(message, user_data):
    try:
        weight_text = message.text.strip().replace(',', '.')
        weight = float(weight_text)
        
        if weight < 30 or weight > 300:
            bot.reply_to(message, "Por favor, digite um peso v√°lido em quilos.")
            return
        
        user_data.weight = str(weight)
        set_user_state(message.from_user.id, UserState.COMPLETED)
        
        # Calcular IMC e enviar relat√≥rio completo
        send_complete_report(message, user_data)
    
    except ValueError:
        bot.reply_to(message, "Por favor, digite apenas n√∫meros para o peso.")

def send_complete_report(message, user_data):
    imc = calculate_imc(user_data.weight, user_data.height)
    
    if imc is None:
        bot.reply_to(message, "‚ùå Erro ao calcular IMC. Verifique os dados.")
        return
    
    classification, icon = get_imc_classification(imc)
    ans_criteria = get_ans_criteria_message(imc)
    pathways = get_pathways_message()
    
    response_msg = get_gendered_message(user_data.name, user_data.gender)
    
    report = f"""{response_msg}

üìä **Seus dados:**
‚Ä¢ Nome: {user_data.name}
‚Ä¢ Idade: {user_data.age} anos
‚Ä¢ Altura: {user_data.height} cm
‚Ä¢ Peso: {user_data.weight} kg

üî¢ **IMC:** {imc} kg/m¬≤
{icon} **Classifica√ß√£o:** {classification}

{ans_criteria}

{pathways}

Posso continuar te ajudando com dicas e orienta√ß√µes sobre o pr√© e p√≥s cir√∫rgico da bari√°trica. √â s√≥ me chamar! üíô"""
    
    bot.reply_to(message, report)

def handle_general_question(message, user_data):
    """Respostas para perguntas gerais"""
    text = message.text.strip()
    
    # Verificar se √© uma pergunta restrita
    if is_restricted_question(text):
        bot.reply_to(message, get_restriction_message())
        return
    
    text_lower = text.lower()
    
    if any(word in text_lower for word in ['dieta', 'alimenta√ß√£o', 'comer', 'comida', 'nutri√ß√£o']):
        response = """Para orienta√ß√µes sobre alimenta√ß√£o, recomendo que voc√™ consulte um nutricionista ou nutr√≥logo habilitado. Eles s√£o os profissionais capacitados para criar planos alimentares adequados √†s suas necessidades.

Posso te ajudar com outras d√∫vidas sobre cirurgia bari√°trica! üíô"""
    
    elif any(word in text_lower for word in ['t√©cnica', 'bypass', 'sleeve', 'banda', 'cirurgia']):
        response = """üî¨ **Principais t√©cnicas:**

‚Ä¢ **Sleeve:** Reduz o tamanho do est√¥mago
‚Ä¢ **Bypass:** Altera o trajeto dos alimentos
‚Ä¢ **Banda:** Utiliza um anel no est√¥mago

A escolha da t√©cnica deve ser discutida com o cirurgi√£o especialista, pois depende de v√°rios fatores individuais.

Para detalhes t√©cnicos espec√≠ficos, consulte profissionais habilitados.

Outras d√∫vidas? üíô"""
    
    elif any(word in text_lower for word in ['recupera√ß√£o', 'p√≥s-operat√≥rio', 'depois']):
        response = """üè• **Recupera√ß√£o:**

‚Ä¢ Acompanhamento m√©dico regular √© fundamental
‚Ä¢ Retorno gradual √†s atividades normais
‚Ä¢ Seguimento das orienta√ß√µes m√©dicas
‚Ä¢ Apoio nutricional e psicol√≥gico

Para informa√ß√µes espec√≠ficas sobre tempos e detalhes do p√≥s-operat√≥rio, consulte seu m√©dico.

Posso ajudar com mais alguma coisa? üíô"""
    
    else:
        response = f"""Ol√°{f', {user_data.name}' if user_data.name else ''}! üíô

Estou aqui para ajudar com d√∫vidas sobre cirurgia bari√°trica. Posso falar sobre:

‚Ä¢ Crit√©rios da ANS
‚Ä¢ Documentos necess√°rios
‚Ä¢ Caminhos (particular, plano, SUS)
‚Ä¢ Orienta√ß√µes gerais

Sobre o que voc√™ gostaria de saber?"""
    
    bot.reply_to(message, response)

# Handlers de erro
@bot.message_handler(func=lambda message: True, content_types=['photo', 'video', 'document', 'audio', 'voice'])
def handle_media(message):
    bot.reply_to(message, "Trabalho apenas com mensagens de texto. Como posso te ajudar? üíô")

def setup_webhook():
    """Configura webhook para produ√ß√£o"""
    if ENVIRONMENT == 'production' and WEBHOOK_URL:
        try:
            bot.remove_webhook()
            bot.set_webhook(url=WEBHOOK_URL)
            logger.info(f"Webhook configurado: {WEBHOOK_URL}")
        except Exception as e:
            logger.error(f"Erro ao configurar webhook: {e}")

def run_bot():
    """Executa o bot"""
    logger.info("ü§ñ BarIA iniciada! Bot rodando...")
    
    if ENVIRONMENT == 'production':
        setup_webhook()
    else:
        bot.remove_webhook()
        bot.infinity_polling()

# Inicializa√ß√£o
if __name__ == "__main__":
    port = int(os.environ.get('PORT', 5000))
    
    if ENVIRONMENT == 'production':
        setup_webhook()
        app.run(host='0.0.0.0', port=port, debug=False)
    else:
        bot_thread = threading.Thread(target=run_bot)
        bot_thread.daemon = True
        bot_thread.start()
        app.run(host='0.0.0.0', port=port, debug=True)
